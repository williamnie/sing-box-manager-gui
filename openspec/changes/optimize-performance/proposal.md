# Proposal: 性能优化

## Why

通过深度代码分析,发现 sing-box-manager 项目在前端渲染、后端并发、存储 I/O 和内存使用等方面存在显著性能优化空间。

当前性能瓶颈包括:
- 前端无条件轮询导致资源浪费
- 后端粗粒度锁限制并发吞吐
- 频繁磁盘 I/O 拖慢响应速度
- 重复计算和序列化浪费 CPU

这些问题在大规模使用场景下(1000+ 节点、多订阅并发刷新)会显著影响用户体验。系统性优化可降低 30-60% 资源消耗,提升响应速度 3-5 倍。

## 概述

通过深度代码分析,识别出 sing-box-manager 项目在前端渲染、后端并发、存储 I/O 和内存使用等方面存在显著优化空间。本提案旨在系统性地提升应用性能,降低资源消耗,改善用户体验。

## 动机

### 已识别的性能瓶颈

**1. 前端性能问题**
- Dashboard 每 5 秒轮询系统状态和监控数据,即使页面不可见
- 所有页面组件在每次状态变更时都重新渲染
- Zustand store 缺少状态选择器,导致不必要的组件更新
- 长列表(订阅、节点、规则)没有虚拟化渲染

**2. 后端并发与锁竞争**
- `JSONStore` 使用粗粒度 `sync.RWMutex`,每次读写都锁定整个数据文件
- 频繁的 `saveInternal()` 调用(每次 CRUD 操作都写磁盘)
- `autoApplyConfig()` 在每个 API 操作后同步执行,阻塞响应
- 订阅刷新 `RefreshAll()` 串行处理,未并发拉取

**3. 存储 I/O 瓶颈**
- 每次数据变更都完整序列化并写入 `data.json`
- 没有写入缓冲或批量提交机制
- JSON 序列化开销随数据规模线性增长
- 配置文件生成(`buildConfig`)每次都重新计算

**4. 内存与资源浪费**
- 订阅节点数据在内存中多次复制
- HTTP 客户端每次请求都创建新实例
- 日志读取一次性加载大量行数(默认 200 行)
- 进程监控使用 `gopsutil` 频繁调用系统 API

## 目标

1. **前端性能提升**
   - 减少 50% 的不必要渲染
   - 实现长列表虚拟化,支持 1000+ 节点流畅滚动
   - 优化轮询策略,页面不可见时暂停

2. **后端响应速度**
   - API 响应时间降低 30-60%
   - 支持并发订阅刷新,提升 3-5 倍速度
   - 异步配置应用,避免阻塞用户操作

3. **存储性能**
   - 实现写入缓冲,减少 70% 的磁盘 I/O
   - 引入配置缓存,避免重复序列化
   - 优化锁粒度,减少竞争

4. **资源使用**
   - 降低 30% 内存占用
   - 减少系统 CPU 消耗
   - 复用 HTTP 连接

## 风险与影响

### 兼容性
- ✅ 所有优化向后兼容现有 API 和数据格式
- ✅ 不影响现有功能行为

### 复杂性
- ⚠️ 写入缓冲增加少量并发复杂度
- ⚠️ 需要测试缓存失效逻辑

### 回退计划
- 所有优化都可独立启用/禁用
- 通过配置开关控制新特性

## 相关变更

本提案包含以下独立优化能力:

1. **frontend-rendering** - 前端渲染优化
2. **backend-concurrency** - 后端并发优化
3. **storage-io** - 存储 I/O 优化
4. **resource-management** - 资源管理优化

每个能力都可独立实现和部署。

## 非目标

- 不涉及架构重构(如数据库替换)
- 不改变现有 API 接口
- 不引入新的外部依赖
